<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/WebSocketManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/WebSocketManager.kt" />
              <option name="originalContent" value="package com.example.qlocktwo&#10;&#10;import android.content.Context&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.engine.cio.CIO&#10;import io.ktor.client.plugins.websocket.WebSockets&#10;import io.ktor.client.plugins.websocket.webSocket&#10;import io.ktor.websocket.DefaultWebSocketSession&#10;import io.ktor.websocket.Frame&#10;import io.ktor.websocket.close&#10;import io.ktor.websocket.readText&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;&#10;enum class ConnectionStatus {&#10;    DISCONNECTED,&#10;    CONNECTING,&#10;    CONNECTED,&#10;    ERROR&#10;}&#10;&#10;class WebSocketManager {&#10;&#10;    val messages = MutableSharedFlow&lt;String&gt;(replay = 1)&#10;    private var session: DefaultWebSocketSession? = null&#10;&#10;    private val _connectionStatus = MutableStateFlow(ConnectionStatus.DISCONNECTED)&#10;    val connectionStatus: StateFlow&lt;ConnectionStatus&gt; = _connectionStatus.asStateFlow()&#10;&#10;    private val client = HttpClient(CIO) {&#10;        install(WebSockets)&#10;    }&#10;&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private var currentHost: String = &quot;192.168.3.219&quot;&#10;    private var currentPort: Int = 81&#10;&#10;    fun connectWithPrefs(context: Context) {&#10;        val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, Context.MODE_PRIVATE)&#10;        val host = prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.219&quot;) ?: &quot;192.168.3.219&quot;&#10;        val port = prefs.getInt(&quot;ws_port&quot;, 81)&#10;        connect(host, port)&#10;    }&#10;&#10;    fun connect(host: String = currentHost, port: Int = currentPort) {&#10;        if (session?.isActive == true &amp;&amp; host == currentHost &amp;&amp; port == currentPort) return&#10;&#10;        currentHost = host&#10;        currentPort = port&#10;        _connectionStatus.value = ConnectionStatus.CONNECTING&#10;&#10;        scope.launch {&#10;            try {&#10;                client.webSocket(host = host, port = port, path = &quot;/ws&quot;) {&#10;                    session = this&#10;                    _connectionStatus.value = ConnectionStatus.CONNECTED&#10;                    println(&quot;WebSocket connection established.&quot;)&#10;                    // Nach Verbindungsaufbau Einstellungen anfordern&#10;                    send(Frame.Text(&quot;GET_SETTINGS&quot;))&#10;                    for (frame in incoming) {&#10;                        if (frame is Frame.Text) {&#10;                            val msg = frame.readText()&#10;                            println(&quot;WebSocket received: $msg&quot;)&#10;                                //TODO update temperature display&#10;                            }&#10;                            else if(msg.startsWith(&quot;SCHEDULE:&quot;)){&#10;                                //TODO pick up the schedule settings for the settings screen&#10;                            }&#10;                            messages.emit(msg)&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot;WebSocket connection failed: \\${e.message}&quot;)&#10;                _connectionStatus.value = ConnectionStatus.ERROR&#10;            } finally {&#10;                println(&quot;WebSocket connection closed.&quot;)&#10;                session = null&#10;                if (_connectionStatus.value != ConnectionStatus.ERROR) {&#10;                    _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendMessage(message: String) {&#10;        scope.launch {&#10;            if (session?.isActive == true) {&#10;                println(&quot;Sending message: $message&quot;)&#10;                session?.send(Frame.Text(message))&#10;            } else {&#10;                println(&quot;Cannot send message, session is not active.&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        scope.launch {&#10;            session?.close()&#10;            session = null&#10;            _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;            println(&quot;WebSocket disconnected.&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.qlocktwo&#10;&#10;import android.content.Context&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.engine.cio.CIO&#10;import io.ktor.client.plugins.websocket.WebSockets&#10;import io.ktor.client.plugins.websocket.webSocket&#10;import io.ktor.websocket.DefaultWebSocketSession&#10;import io.ktor.websocket.Frame&#10;import io.ktor.websocket.close&#10;import io.ktor.websocket.readText&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;&#10;enum class ConnectionStatus {&#10;    DISCONNECTED,&#10;    CONNECTING,&#10;    CONNECTED,&#10;    ERROR&#10;}&#10;&#10;class WebSocketManager {&#10;&#10;    val messages = MutableSharedFlow&lt;String&gt;(replay = 0)&#10;    private var session: DefaultWebSocketSession? = null&#10;&#10;    private val _connectionStatus = MutableStateFlow(ConnectionStatus.DISCONNECTED)&#10;    val connectionStatus: StateFlow&lt;ConnectionStatus&gt; = _connectionStatus.asStateFlow()&#10;&#10;    // StateFlow für aktuelle Settings, damit mehrere Komponenten darauf zugreifen können&#10;    private val _currentSettings = MutableStateFlow&lt;String?&gt;(null)&#10;    val currentSettings: StateFlow&lt;String?&gt; = _currentSettings.asStateFlow()&#10;&#10;    // StateFlow für aktuelle Temperatur&#10;    private val _currentTemperature = MutableStateFlow&lt;Int?&gt;(null)&#10;    val currentTemperature: StateFlow&lt;Int?&gt; = _currentTemperature.asStateFlow()&#10;&#10;    // StateFlow für Schedule-Einstellungen&#10;    data class ScheduleSettings(&#10;        val enabled: Boolean,&#10;        val startHour: Int,&#10;        val startMinute: Int,&#10;        val endHour: Int,&#10;        val endMinute: Int&#10;    )&#10;    private val _currentSchedule = MutableStateFlow&lt;ScheduleSettings?&gt;(null)&#10;    val currentSchedule: StateFlow&lt;ScheduleSettings?&gt; = _currentSchedule.asStateFlow()&#10;&#10;    private val client = HttpClient(CIO) {&#10;        install(WebSockets)&#10;    }&#10;&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private var currentHost: String = &quot;192.168.3.219&quot;&#10;    private var currentPort: Int = 81&#10;&#10;    fun connectWithPrefs(context: Context) {&#10;        val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, Context.MODE_PRIVATE)&#10;        val host = prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.219&quot;) ?: &quot;192.168.3.219&quot;&#10;        val port = prefs.getInt(&quot;ws_port&quot;, 81)&#10;        connect(host, port)&#10;    }&#10;&#10;    fun connect(host: String = currentHost, port: Int = currentPort) {&#10;        if (session?.isActive == true &amp;&amp; host == currentHost &amp;&amp; port == currentPort) return&#10;&#10;        currentHost = host&#10;        currentPort = port&#10;        _connectionStatus.value = ConnectionStatus.CONNECTING&#10;&#10;        scope.launch {&#10;            try {&#10;                client.webSocket(host = host, port = port, path = &quot;/ws&quot;) {&#10;                    session = this&#10;                    _connectionStatus.value = ConnectionStatus.CONNECTED&#10;                    println(&quot;WebSocket connection established.&quot;)&#10;                    // Nach Verbindungsaufbau Einstellungen anfordern&#10;                    send(Frame.Text(&quot;GET_SETTINGS&quot;))&#10;                    for (frame in incoming) {&#10;                        if (frame is Frame.Text) {&#10;                            val msg = frame.readText()&#10;                            println(&quot;WebSocket received: $msg&quot;)&#10;&#10;                            // Settings separat im StateFlow speichern&#10;                            if (msg.startsWith(&quot;SETTINGS:&quot;)) {&#10;                                _currentSettings.value = msg&#10;                            }&#10;                            else if(msg.startsWith(&quot;TEMP:&quot;)) {&#10;                                // Parse und update Temperatur&#10;                                val tempStr = msg.removePrefix(&quot;TEMP:&quot;)&#10;                                val temp = tempStr.toIntOrNull()&#10;                                if (temp != null) {&#10;                                    _currentTemperature.value = temp&#10;                                    println(&quot;Temperature updated: $temp°C&quot;)&#10;                                }&#10;                            }&#10;                            else if(msg.startsWith(&quot;SCHEDULE:&quot;)){&#10;                                // Parse und update Schedule&#10;                                val scheduleStr = msg.removePrefix(&quot;SCHEDULE:&quot;)&#10;                                if (scheduleStr == &quot;OFF&quot;) {&#10;                                    _currentSchedule.value = ScheduleSettings(&#10;                                        enabled = false,&#10;                                        startHour = 7,&#10;                                        startMinute = 0,&#10;                                        endHour = 22,&#10;                                        endMinute = 0&#10;                                    )&#10;                                    println(&quot;Schedule updated: OFF&quot;)&#10;                                } else if (scheduleStr.startsWith(&quot;ON,&quot;)) {&#10;                                    // Format: ON,HH:MM,HH:MM&#10;                                    val parts = scheduleStr.removePrefix(&quot;ON,&quot;).split(&quot;,&quot;)&#10;                                    if (parts.size == 2) {&#10;                                        val startParts = parts[0].split(&quot;:&quot;)&#10;                                        val endParts = parts[1].split(&quot;:&quot;)&#10;                                        if (startParts.size == 2 &amp;&amp; endParts.size == 2) {&#10;                                            val startHour = startParts[0].toIntOrNull()&#10;                                            val startMinute = startParts[1].toIntOrNull()&#10;                                            val endHour = endParts[0].toIntOrNull()&#10;                                            val endMinute = endParts[1].toIntOrNull()&#10;                                            &#10;                                            if (startHour != null &amp;&amp; startMinute != null &amp;&amp; &#10;                                                endHour != null &amp;&amp; endMinute != null) {&#10;                                                _currentSchedule.value = ScheduleSettings(&#10;                                                    enabled = true,&#10;                                                    startHour = startHour,&#10;                                                    startMinute = startMinute,&#10;                                                    endHour = endHour,&#10;                                                    endMinute = endMinute&#10;                                                )&#10;                                                println(&quot;Schedule updated: ON from $startHour:$startMinute to $endHour:$endMinute&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                            messages.emit(msg)&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot;WebSocket connection failed: \\${e.message}&quot;)&#10;                _connectionStatus.value = ConnectionStatus.ERROR&#10;            } finally {&#10;                println(&quot;WebSocket connection closed.&quot;)&#10;                session = null&#10;                if (_connectionStatus.value != ConnectionStatus.ERROR) {&#10;                    _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendMessage(message: String) {&#10;        scope.launch {&#10;            if (session?.isActive == true) {&#10;                println(&quot;Sending message: $message&quot;)&#10;                session?.send(Frame.Text(message))&#10;            } else {&#10;                println(&quot;Cannot send message, session is not active.&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        scope.launch {&#10;            session?.close()&#10;            session = null&#10;            _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;            println(&quot;WebSocket disconnected.&quot;)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/screens/SettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/screens/SettingsScreen.kt" />
              <option name="originalContent" value="package com.example.qlocktwo.screens&#10;&#10;import android.app.TimePickerDialog&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import com.example.qlocktwo.R&#10;import com.example.qlocktwo.WebSocketManager&#10;import kotlinx.coroutines.flow.collectLatest&#10;import java.util.Calendar&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SettingsScreen(&#10;    webSocketManager: WebSocketManager,&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, android.content.Context.MODE_PRIVATE)&#10;&#10;    var isScheduleEnabled by remember {&#10;        mutableStateOf(prefs.getBoolean(&quot;schedule_enabled&quot;, false))&#10;    }&#10;    var startHour by remember { mutableStateOf(prefs.getInt(&quot;start_hour&quot;, 7)) }&#10;    var startMinute by remember { mutableStateOf(prefs.getInt(&quot;start_minute&quot;, 0)) }&#10;    var endHour by remember { mutableStateOf(prefs.getInt(&quot;end_hour&quot;, 22)) }&#10;    var endMinute by remember { mutableStateOf(prefs.getInt(&quot;end_minute&quot;, 0)) }&#10;&#10;    var ipAddress by remember { mutableStateOf(prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.219&quot;) ?: &quot;192.168.3.219&quot;) }&#10;    var port by remember { mutableStateOf(prefs.getInt(&quot;ws_port&quot;, 81).toString()) }&#10;    var ipError by remember { mutableStateOf(false) }&#10;    var portError by remember { mutableStateOf(false) }&#10;&#10;    Scaffold { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 16.dp, vertical = 8.dp)&#10;                .verticalScroll(rememberScrollState()),&#10;            verticalArrangement = Arrangement.spacedBy(24.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Allgemeine Einstellungen&quot;,&#10;                style = MaterialTheme.typography.titleLarge,&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            // IP/Port Card&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&quot;Verbindungsdaten&quot;, style = MaterialTheme.typography.titleMedium)&#10;                    androidx.compose.material3.OutlinedTextField(&#10;                        value = ipAddress,&#10;                        onValueChange = {&#10;                            ipAddress = it&#10;                            ipError = !Regex(&quot;^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;).matches(it)&#10;                        },&#10;                        label = { Text(&quot;IP-Adresse&quot;) },&#10;                        isError = ipError,&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                    if (ipError) Text(&quot;Ungültige IP-Adresse&quot;, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)&#10;                    androidx.compose.material3.OutlinedTextField(&#10;                        value = port,&#10;                        onValueChange = {&#10;                            port = it.filter { c -&gt; c.isDigit() }&#10;                            portError = port.isEmpty() || port.toIntOrNull() == null || port.toInt() !in 1..65535&#10;                        },&#10;                        label = { Text(&quot;Port&quot;) },&#10;                        isError = portError,&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                    if (portError) Text(&quot;Ungültiger Port (1-65535)&quot;, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)&#10;                    Button(&#10;                        onClick = {&#10;                            if (!ipError &amp;&amp; !portError) {&#10;                                prefs.edit().putString(&quot;ws_ip&quot;, ipAddress).putInt(&quot;ws_port&quot;, port.toInt()).apply()&#10;                                webSocketManager.disconnect()&#10;                                webSocketManager.connect(ipAddress, port.toInt())&#10;                            }&#10;                        },&#10;                        enabled = !ipError &amp;&amp; !portError,&#10;                        modifier = Modifier.align(Alignment.End)&#10;                    ) {&#10;                        Text(&quot;Übernehmen &amp; neu verbinden&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(18.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&quot;Zeitplan aktivieren&quot;, style = MaterialTheme.typography.bodyLarge)&#10;                        Switch(&#10;                            checked = isScheduleEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                isScheduleEnabled = enabled&#10;                                prefs.edit().putBoolean(&quot;schedule_enabled&quot;, enabled).apply()&#10;                                val message = if (enabled) {&#10;                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                } else {&#10;                                    &quot;SCHEDULE:OFF&quot;&#10;                                }&#10;                                webSocketManager.sendMessage(message)&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    if (isScheduleEnabled) {&#10;                        Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&quot;Startzeit&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                Button(&#10;                                    onClick = {&#10;                                        TimePickerDialog(&#10;                                            context,&#10;                                            { _, hour, minute -&gt;&#10;                                                startHour = hour&#10;                                                startMinute = minute&#10;                                                prefs.edit()&#10;                                                    .putInt(&quot;start_hour&quot;, hour)&#10;                                                    .putInt(&quot;start_minute&quot;, minute)&#10;                                                    .apply()&#10;                                                webSocketManager.sendMessage(&#10;                                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                                )&#10;                                            },&#10;                                            startHour,&#10;                                            startMinute,&#10;                                            true&#10;                                        ).show()&#10;                                    },&#10;                                    shape = MaterialTheme.shapes.medium&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = android.R.drawable.ic_menu_recent_history),&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.padding(end = 4.dp)&#10;                                    )&#10;                                    Text(String.format(&quot;%02d:%02d&quot;, startHour, startMinute))&#10;                                }&#10;                            }&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&quot;Endzeit&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                Button(&#10;                                    onClick = {&#10;                                        TimePickerDialog(&#10;                                            context,&#10;                                            { _, hour, minute -&gt;&#10;                                                endHour = hour&#10;                                                endMinute = minute&#10;                                                prefs.edit()&#10;                                                    .putInt(&quot;end_hour&quot;, hour)&#10;                                                    .putInt(&quot;end_minute&quot;, minute)&#10;                                                    .apply()&#10;                                                webSocketManager.sendMessage(&#10;                                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                                )&#10;                                            },&#10;                                            endHour,&#10;                                            endMinute,&#10;                                            true&#10;                                        ).show()&#10;                                    },&#10;                                    shape = MaterialTheme.shapes.medium&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = android.R.drawable.ic_menu_recent_history),&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.padding(end = 4.dp)&#10;                                    )&#10;                                    Text(String.format(&quot;%02d:%02d&quot;, endHour, endMinute))&#10;                                }&#10;                            }&#10;                            Text(&#10;                                text = &quot;Die Uhr ist aktiv von ${String.format(&quot;%02d:%02d&quot;, startHour, startMinute)} bis ${String.format(&quot;%02d:%02d&quot;, endHour, endMinute)}.&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                                modifier = Modifier.padding(top = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.qlocktwo.screens&#10;&#10;import android.app.TimePickerDialog&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import com.example.qlocktwo.R&#10;import com.example.qlocktwo.WebSocketManager&#10;import kotlinx.coroutines.flow.collectLatest&#10;import java.util.Calendar&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SettingsScreen(&#10;    webSocketManager: WebSocketManager,&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, android.content.Context.MODE_PRIVATE)&#10;&#10;    var isScheduleEnabled by remember {&#10;        mutableStateOf(prefs.getBoolean(&quot;schedule_enabled&quot;, false))&#10;    }&#10;    var startHour by remember { mutableStateOf(prefs.getInt(&quot;start_hour&quot;, 7)) }&#10;    var startMinute by remember { mutableStateOf(prefs.getInt(&quot;start_minute&quot;, 0)) }&#10;    var endHour by remember { mutableStateOf(prefs.getInt(&quot;end_hour&quot;, 22)) }&#10;    var endMinute by remember { mutableStateOf(prefs.getInt(&quot;end_minute&quot;, 0)) }&#10;&#10;    var ipAddress by remember { mutableStateOf(prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.219&quot;) ?: &quot;192.168.3.219&quot;) }&#10;    var port by remember { mutableStateOf(prefs.getInt(&quot;ws_port&quot;, 81).toString()) }&#10;    var ipError by remember { mutableStateOf(false) }&#10;    var portError by remember { mutableStateOf(false) }&#10;&#10;    // Listen for schedule updates from ESP32&#10;    LaunchedEffect(webSocketManager) {&#10;        webSocketManager.currentSchedule.collect { scheduleSettings -&gt;&#10;            scheduleSettings?.let {&#10;                isScheduleEnabled = it.enabled&#10;                startHour = it.startHour&#10;                startMinute = it.startMinute&#10;                endHour = it.endHour&#10;                endMinute = it.endMinute&#10;                &#10;                // Save to SharedPreferences&#10;                prefs.edit()&#10;                    .putBoolean(&quot;schedule_enabled&quot;, it.enabled)&#10;                    .putInt(&quot;start_hour&quot;, it.startHour)&#10;                    .putInt(&quot;start_minute&quot;, it.startMinute)&#10;                    .putInt(&quot;end_hour&quot;, it.endHour)&#10;                    .putInt(&quot;end_minute&quot;, it.endMinute)&#10;                    .apply()&#10;                &#10;                println(&quot;SettingsScreen: Schedule updated from ESP32 - enabled=${it.enabled}, ${it.startHour}:${it.startMinute} - ${it.endHour}:${it.endMinute}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 16.dp, vertical = 8.dp)&#10;                .verticalScroll(rememberScrollState()),&#10;            verticalArrangement = Arrangement.spacedBy(24.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Allgemeine Einstellungen&quot;,&#10;                style = MaterialTheme.typography.titleLarge,&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            // IP/Port Card&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&quot;Verbindungsdaten&quot;, style = MaterialTheme.typography.titleMedium)&#10;                    androidx.compose.material3.OutlinedTextField(&#10;                        value = ipAddress,&#10;                        onValueChange = {&#10;                            ipAddress = it&#10;                            ipError = !Regex(&quot;^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;).matches(it)&#10;                        },&#10;                        label = { Text(&quot;IP-Adresse&quot;) },&#10;                        isError = ipError,&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                    if (ipError) Text(&quot;Ungültige IP-Adresse&quot;, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)&#10;                    androidx.compose.material3.OutlinedTextField(&#10;                        value = port,&#10;                        onValueChange = {&#10;                            port = it.filter { c -&gt; c.isDigit() }&#10;                            portError = port.isEmpty() || port.toIntOrNull() == null || port.toInt() !in 1..65535&#10;                        },&#10;                        label = { Text(&quot;Port&quot;) },&#10;                        isError = portError,&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                    if (portError) Text(&quot;Ungültiger Port (1-65535)&quot;, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)&#10;                    Button(&#10;                        onClick = {&#10;                            if (!ipError &amp;&amp; !portError) {&#10;                                prefs.edit().putString(&quot;ws_ip&quot;, ipAddress).putInt(&quot;ws_port&quot;, port.toInt()).apply()&#10;                                webSocketManager.disconnect()&#10;                                webSocketManager.connect(ipAddress, port.toInt())&#10;                            }&#10;                        },&#10;                        enabled = !ipError &amp;&amp; !portError,&#10;                        modifier = Modifier.align(Alignment.End)&#10;                    ) {&#10;                        Text(&quot;Übernehmen &amp; neu verbinden&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(18.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&quot;Zeitplan aktivieren&quot;, style = MaterialTheme.typography.bodyLarge)&#10;                        Switch(&#10;                            checked = isScheduleEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                isScheduleEnabled = enabled&#10;                                prefs.edit().putBoolean(&quot;schedule_enabled&quot;, enabled).apply()&#10;                                val message = if (enabled) {&#10;                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                } else {&#10;                                    &quot;SCHEDULE:OFF&quot;&#10;                                }&#10;                                webSocketManager.sendMessage(message)&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    if (isScheduleEnabled) {&#10;                        Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&quot;Startzeit&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                Button(&#10;                                    onClick = {&#10;                                        TimePickerDialog(&#10;                                            context,&#10;                                            { _, hour, minute -&gt;&#10;                                                startHour = hour&#10;                                                startMinute = minute&#10;                                                prefs.edit()&#10;                                                    .putInt(&quot;start_hour&quot;, hour)&#10;                                                    .putInt(&quot;start_minute&quot;, minute)&#10;                                                    .apply()&#10;                                                webSocketManager.sendMessage(&#10;                                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                                )&#10;                                            },&#10;                                            startHour,&#10;                                            startMinute,&#10;                                            true&#10;                                        ).show()&#10;                                    },&#10;                                    shape = MaterialTheme.shapes.medium&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = android.R.drawable.ic_menu_recent_history),&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.padding(end = 4.dp)&#10;                                    )&#10;                                    Text(String.format(&quot;%02d:%02d&quot;, startHour, startMinute))&#10;                                }&#10;                            }&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&quot;Endzeit&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                Button(&#10;                                    onClick = {&#10;                                        TimePickerDialog(&#10;                                            context,&#10;                                            { _, hour, minute -&gt;&#10;                                                endHour = hour&#10;                                                endMinute = minute&#10;                                                prefs.edit()&#10;                                                    .putInt(&quot;end_hour&quot;, hour)&#10;                                                    .putInt(&quot;end_minute&quot;, minute)&#10;                                                    .apply()&#10;                                                webSocketManager.sendMessage(&#10;                                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                                )&#10;                                            },&#10;                                            endHour,&#10;                                            endMinute,&#10;                                            true&#10;                                        ).show()&#10;                                    },&#10;                                    shape = MaterialTheme.shapes.medium&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = android.R.drawable.ic_menu_recent_history),&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.padding(end = 4.dp)&#10;                                    )&#10;                                    Text(String.format(&quot;%02d:%02d&quot;, endHour, endMinute))&#10;                                }&#10;                            }&#10;                            Text(&#10;                                text = &quot;Die Uhr ist aktiv von ${String.format(&quot;%02d:%02d&quot;, startHour, startMinute)} bis ${String.format(&quot;%02d:%02d&quot;, endHour, endMinute)}.&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                                modifier = Modifier.padding(top = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/screens/TemperatureScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/screens/TemperatureScreen.kt" />
              <option name="originalContent" value="package com.example.qlocktwo.screens&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.qlocktwo.WebSocketManager&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;&#10;@Composable&#10;fun TemperatureScreen(&#10;    colorViewModel: ColorViewModel,&#10;    webSocketManager: WebSocketManager&#10;) {&#10;    val allMessages by webSocketManager.messages.collectAsState(initial = &quot;&quot;)&#10;    // Logging der empfangenen Nachricht&#10;    Log.d(&quot;TemperatureScreen&quot;, &quot;Received WebSocket message: $allMessages&quot;)&#10;    // Extrahiere die letzte TEMP-Nachricht aus dem Flow&#10;    val temperature = remember(allMessages) {&#10;        val tempMsg = allMessages.split(&quot;\n&quot;).lastOrNull { it.startsWith(&quot;TEMP:&quot;) }&#10;        tempMsg?.removePrefix(&quot;TEMP:&quot;)?.toIntOrNull() ?: 20&#10;    }&#10;&#10;    val matrix = listOf(&#10;        &quot;ESKISTAFÜNF&quot;,&#10;        &quot;ZEHNJEPSORM&quot;,&#10;        &quot;AFAXZWANZIG&quot;,&#10;        &quot;DREIVIERTEL&quot;,&#10;        &quot;VORFUNKNACH&quot;,&#10;        &quot;HALBAELFÜNF&quot;,&#10;        &quot;EINSXAMZWEI&quot;,&#10;        &quot;DREIPMJVIER&quot;,&#10;        &quot;SECHSNLACHT&quot;,&#10;        &quot;SIEBENZWÖLF&quot;,&#10;        &quot;ZEHNEUNKUHR&quot;&#10;    )&#10;&#10;    val digit1 = if (temperature &gt;= 10) temperature / 10 else -1  // -1 means no digit&#10;    val digit2 = temperature % 10&#10;&#10;    val pixelMatrix = createTemperatureMatrix(digit1, digit2)&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        CommonControls(&#10;            modifier = Modifier.padding(top = 48.dp),&#10;            colorViewModel = colorViewModel,&#10;            onSendMessage = webSocketManager::sendMessage&#10;        )&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            TemperatureMatrix(&#10;                matrix = matrix,&#10;                pixelMatrix = pixelMatrix,&#10;                color = colorViewModel.selectedColor&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TemperatureMatrix(&#10;    matrix: List&lt;String&gt;,&#10;    pixelMatrix: Array&lt;BooleanArray&gt;,&#10;    color: Color&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(4.dp)&#10;    ) {&#10;        matrix.forEachIndexed { rowIndex, row -&gt;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                row.forEachIndexed { colIndex, char -&gt;&#10;                    val isOn = pixelMatrix[rowIndex][colIndex]&#10;                    TemperatureLetterBox(&#10;                        letter = char,&#10;                        isOn = isOn,&#10;                        color = color,&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TemperatureLetterBox(&#10;    letter: Char,&#10;    isOn: Boolean,&#10;    color: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier.aspectRatio(1f),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = letter.toString(),&#10;            fontSize = 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = if (isOn) color else Color(0xFF333333)&#10;        )&#10;    }&#10;}&#10;&#10;fun createTemperatureMatrix(digit1: Int, digit2: Int): Array&lt;BooleanArray&gt; {&#10;    val matrix = Array(11) { BooleanArray(11) { false } }&#10;&#10;    if (digit1 &gt;= 0) {&#10;        // Two digits: draw first digit at columns 0-4, second at 6-10&#10;        drawTempDigit(matrix, digit1, 0)&#10;        drawTempDigit(matrix, digit2, 6)&#10;    } else {&#10;        // One digit: draw centered at columns 1-5&#10;        drawTempDigit(matrix, digit2, 1)&#10;    }&#10;&#10;    // Draw degree symbol at column 7 or 8 (depending on number of digits)&#10;    val degreeCol = if (digit1 &gt;= 0) 0 else 7  // Position after the digits&#10;    if (degreeCol &gt; 0) {&#10;        drawDegreeSymbol(matrix, degreeCol)&#10;    }&#10;&#10;    return matrix&#10;}&#10;&#10;fun drawTempDigit(matrix: Array&lt;BooleanArray&gt;, digit: Int, startCol: Int) {&#10;    val digitPattern = getTempDigitPattern(digit)&#10;&#10;    // Center the digit vertically (start at row 2, use 7 rows)&#10;    val startRow = 2&#10;&#10;    digitPattern.forEachIndexed { row, line -&gt;&#10;        line.forEachIndexed { col, pixel -&gt;&#10;            if (pixel &amp;&amp; startCol + col &lt; 11) {&#10;                matrix[startRow + row][startCol + col] = true&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun drawDegreeSymbol(matrix: Array&lt;BooleanArray&gt;, startCol: Int) {&#10;    // Small degree circle (3x3) positioned at top of digits&#10;    val startRow = 2&#10;&#10;    // Draw a small circle&#10;    if (startCol + 2 &lt; 11) {&#10;        matrix[startRow][startCol] = true&#10;        matrix[startRow][startCol + 1] = true&#10;        matrix[startRow][startCol + 2] = true&#10;        matrix[startRow + 1][startCol] = true&#10;        matrix[startRow + 1][startCol + 2] = true&#10;        matrix[startRow + 2][startCol] = true&#10;        matrix[startRow + 2][startCol + 1] = true&#10;        matrix[startRow + 2][startCol + 2] = true&#10;    }&#10;}&#10;&#10;fun getTempDigitPattern(digit: Int): Array&lt;BooleanArray&gt; {&#10;    // 5x7 pixel patterns for digits 0-9 (reusing from DigitalClockScreen logic)&#10;    return when (digit) {&#10;        0 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        1 -&gt; arrayOf(&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, true, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, true, true, true, false)&#10;        )&#10;        2 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        3 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        4 -&gt; arrayOf(&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true)&#10;        )&#10;        5 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        6 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        7 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, true, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false)&#10;        )&#10;        8 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        9 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        else -&gt; Array(7) { BooleanArray(5) { false } }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.qlocktwo.screens&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.qlocktwo.WebSocketManager&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;&#10;@Composable&#10;fun TemperatureScreen(&#10;    colorViewModel: ColorViewModel,&#10;    webSocketManager: WebSocketManager&#10;) {&#10;    // Collect temperature directly from dedicated StateFlow&#10;    val temperature by webSocketManager.currentTemperature.collectAsState()&#10;    &#10;    // Logging der Temperatur&#10;    Log.d(&quot;TemperatureScreen&quot;, &quot;Current temperature: $temperature°C&quot;)&#10;&#10;    val matrix = listOf(&#10;        &quot;ESKISTAFÜNF&quot;,&#10;        &quot;ZEHNJEPSORM&quot;,&#10;        &quot;AFAXZWANZIG&quot;,&#10;        &quot;DREIVIERTEL&quot;,&#10;        &quot;VORFUNKNACH&quot;,&#10;        &quot;HALBAELFÜNF&quot;,&#10;        &quot;EINSXAMZWEI&quot;,&#10;        &quot;DREIPMJVIER&quot;,&#10;        &quot;SECHSNLACHT&quot;,&#10;        &quot;SIEBENZWÖLF&quot;,&#10;        &quot;ZEHNEUNKUHR&quot;&#10;    )&#10;&#10;    // Use default value of 20 if temperature is null&#10;    val tempValue = temperature ?: 20&#10;    val digit1 = if (tempValue &gt;= 10) tempValue / 10 else -1  // -1 means no digit&#10;    val digit2 = tempValue % 10&#10;&#10;    val pixelMatrix = createTemperatureMatrix(digit1, digit2)&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        CommonControls(&#10;            modifier = Modifier.padding(top = 48.dp),&#10;            colorViewModel = colorViewModel,&#10;            onSendMessage = webSocketManager::sendMessage&#10;        )&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            TemperatureMatrix(&#10;                matrix = matrix,&#10;                pixelMatrix = pixelMatrix,&#10;                color = colorViewModel.selectedColor&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TemperatureMatrix(&#10;    matrix: List&lt;String&gt;,&#10;    pixelMatrix: Array&lt;BooleanArray&gt;,&#10;    color: Color&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(4.dp)&#10;    ) {&#10;        matrix.forEachIndexed { rowIndex, row -&gt;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                row.forEachIndexed { colIndex, char -&gt;&#10;                    val isOn = pixelMatrix[rowIndex][colIndex]&#10;                    TemperatureLetterBox(&#10;                        letter = char,&#10;                        isOn = isOn,&#10;                        color = color,&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TemperatureLetterBox(&#10;    letter: Char,&#10;    isOn: Boolean,&#10;    color: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier.aspectRatio(1f),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = letter.toString(),&#10;            fontSize = 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = if (isOn) color else Color(0xFF333333)&#10;        )&#10;    }&#10;}&#10;&#10;fun createTemperatureMatrix(digit1: Int, digit2: Int): Array&lt;BooleanArray&gt; {&#10;    val matrix = Array(11) { BooleanArray(11) { false } }&#10;&#10;    if (digit1 &gt;= 0) {&#10;        // Two digits: draw first digit at columns 0-4, second at 6-10&#10;        drawTempDigit(matrix, digit1, 0)&#10;        drawTempDigit(matrix, digit2, 6)&#10;    } else {&#10;        // One digit: draw centered at columns 1-5&#10;        drawTempDigit(matrix, digit2, 1)&#10;    }&#10;&#10;    // Draw degree symbol at column 7 or 8 (depending on number of digits)&#10;    val degreeCol = if (digit1 &gt;= 0) 0 else 7  // Position after the digits&#10;    if (degreeCol &gt; 0) {&#10;        drawDegreeSymbol(matrix, degreeCol)&#10;    }&#10;&#10;    return matrix&#10;}&#10;&#10;fun drawTempDigit(matrix: Array&lt;BooleanArray&gt;, digit: Int, startCol: Int) {&#10;    val digitPattern = getTempDigitPattern(digit)&#10;&#10;    // Center the digit vertically (start at row 2, use 7 rows)&#10;    val startRow = 2&#10;&#10;    digitPattern.forEachIndexed { row, line -&gt;&#10;        line.forEachIndexed { col, pixel -&gt;&#10;            if (pixel &amp;&amp; startCol + col &lt; 11) {&#10;                matrix[startRow + row][startCol + col] = true&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun drawDegreeSymbol(matrix: Array&lt;BooleanArray&gt;, startCol: Int) {&#10;    // Small degree circle (3x3) positioned at top of digits&#10;    val startRow = 2&#10;&#10;    // Draw a small circle&#10;    if (startCol + 2 &lt; 11) {&#10;        matrix[startRow][startCol] = true&#10;        matrix[startRow][startCol + 1] = true&#10;        matrix[startRow][startCol + 2] = true&#10;        matrix[startRow + 1][startCol] = true&#10;        matrix[startRow + 1][startCol + 2] = true&#10;        matrix[startRow + 2][startCol] = true&#10;        matrix[startRow + 2][startCol + 1] = true&#10;        matrix[startRow + 2][startCol + 2] = true&#10;    }&#10;}&#10;&#10;fun getTempDigitPattern(digit: Int): Array&lt;BooleanArray&gt; {&#10;    // 5x7 pixel patterns for digits 0-9 (reusing from DigitalClockScreen logic)&#10;    return when (digit) {&#10;        0 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        1 -&gt; arrayOf(&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, true, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, true, true, true, false)&#10;        )&#10;        2 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        3 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        4 -&gt; arrayOf(&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true)&#10;        )&#10;        5 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        6 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, false, false, false, false),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        7 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, true, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false),&#10;            booleanArrayOf(false, false, true, false, false)&#10;        )&#10;        8 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        9 -&gt; arrayOf(&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(false, false, false, false, true),&#10;            booleanArrayOf(true, true, true, true, true)&#10;        )&#10;        else -&gt; Array(7) { BooleanArray(5) { false } }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>