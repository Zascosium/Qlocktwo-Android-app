<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/MainActivity.kt" />
              <option name="originalContent" value="package com.example.qlocktwo&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.qlocktwo.screens.MainScreen&#10;import com.example.qlocktwo.ui.theme.QlocktwoTheme&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;import com.example.qlocktwo.viewmodels.ColorViewModelFactory&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val webSocketManager = WebSocketManager()&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        // IP und Port aus SharedPreferences laden&#10;        val prefs = getSharedPreferences(&quot;QlockSettings&quot;, MODE_PRIVATE)&#10;        val wsIp = prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.210&quot;) ?: &quot;192.168.3.210&quot;&#10;        val wsPort = prefs.getInt(&quot;ws_port&quot;, 81)&#10;        webSocketManager.connect(wsIp, wsPort)&#10;        setContent {&#10;            val colorViewModel: ColorViewModel = androidx.lifecycle.viewmodel.compose.viewModel(&#10;                factory = ColorViewModelFactory(application)&#10;            )&#10;            QlocktwoTheme(darkTheme = true) {&#10;                MainScreen(&#10;                    webSocketManager = webSocketManager,&#10;                    colorViewModel = colorViewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.qlocktwo&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.qlocktwo.screens.MainScreen&#10;import com.example.qlocktwo.ui.theme.QlocktwoTheme&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;import com.example.qlocktwo.viewmodels.ColorViewModelFactory&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val webSocketManager = WebSocketManager()&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        webSocketManager.connectWithPrefs(this)&#10;        setContent {&#10;            val colorViewModel: ColorViewModel = androidx.lifecycle.viewmodel.compose.viewModel(&#10;                factory = ColorViewModelFactory(application)&#10;            )&#10;            QlocktwoTheme(darkTheme = true) {&#10;                MainScreen(&#10;                    webSocketManager = webSocketManager,&#10;                    colorViewModel = colorViewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/WebSocketManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/WebSocketManager.kt" />
              <option name="originalContent" value="package com.example.qlocktwo&#10;&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.engine.cio.CIO&#10;import io.ktor.client.plugins.websocket.WebSockets&#10;import io.ktor.client.plugins.websocket.webSocket&#10;import io.ktor.websocket.DefaultWebSocketSession&#10;import io.ktor.websocket.Frame&#10;import io.ktor.websocket.close&#10;import io.ktor.websocket.readText&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;&#10;enum class ConnectionStatus {&#10;    DISCONNECTED,&#10;    CONNECTING,&#10;    CONNECTED,&#10;    ERROR&#10;}&#10;&#10;class WebSocketManager {&#10;&#10;    val messages = MutableSharedFlow&lt;String&gt;(replay = 1)&#10;    private var session: DefaultWebSocketSession? = null&#10;&#10;    private val _connectionStatus = MutableStateFlow(ConnectionStatus.DISCONNECTED)&#10;    val connectionStatus: StateFlow&lt;ConnectionStatus&gt; = _connectionStatus.asStateFlow()&#10;&#10;    private val client = HttpClient(CIO) {&#10;        install(WebSockets)&#10;    }&#10;&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private var currentHost: String = &quot;192.168.3.210&quot;&#10;    private var currentPort: Int = 81&#10;&#10;    fun connect(host: String = currentHost, port: Int = currentPort) {&#10;        if (session?.isActive == true &amp;&amp; host == currentHost &amp;&amp; port == currentPort) return&#10;&#10;        currentHost = host&#10;        currentPort = port&#10;        _connectionStatus.value = ConnectionStatus.CONNECTING&#10;&#10;        scope.launch {&#10;            try {&#10;                client.webSocket(host = host, port = port, path = &quot;/ws&quot;) {&#10;                    session = this&#10;                    _connectionStatus.value = ConnectionStatus.CONNECTED&#10;                    println(&quot;WebSocket connection established.&quot;)&#10;                    // Nach Verbindungsaufbau Einstellungen anfordern&#10;                    send(Frame.Text(&quot;GET_SETTINGS&quot;))&#10;                    for (frame in incoming) {&#10;                        if (frame is Frame.Text) {&#10;                            messages.emit(frame.readText())&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot;WebSocket connection failed: \\${e.message}&quot;)&#10;                _connectionStatus.value = ConnectionStatus.ERROR&#10;            } finally {&#10;                println(&quot;WebSocket connection closed.&quot;)&#10;                session = null&#10;                if (_connectionStatus.value != ConnectionStatus.ERROR) {&#10;                    _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendMessage(message: String) {&#10;        scope.launch {&#10;            if (session?.isActive == true) {&#10;                println(&quot;Sending message: $message&quot;)&#10;                session?.send(Frame.Text(message))&#10;            } else {&#10;                println(&quot;Cannot send message, session is not active.&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        scope.launch {&#10;            session?.close()&#10;            session = null&#10;            _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;            println(&quot;WebSocket disconnected.&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.qlocktwo&#10;&#10;import android.content.Context&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.engine.cio.CIO&#10;import io.ktor.client.plugins.websocket.WebSockets&#10;import io.ktor.client.plugins.websocket.webSocket&#10;import io.ktor.websocket.DefaultWebSocketSession&#10;import io.ktor.websocket.Frame&#10;import io.ktor.websocket.close&#10;import io.ktor.websocket.readText&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;&#10;enum class ConnectionStatus {&#10;    DISCONNECTED,&#10;    CONNECTING,&#10;    CONNECTED,&#10;    ERROR&#10;}&#10;&#10;class WebSocketManager {&#10;&#10;    val messages = MutableSharedFlow&lt;String&gt;(replay = 1)&#10;    private var session: DefaultWebSocketSession? = null&#10;&#10;    private val _connectionStatus = MutableStateFlow(ConnectionStatus.DISCONNECTED)&#10;    val connectionStatus: StateFlow&lt;ConnectionStatus&gt; = _connectionStatus.asStateFlow()&#10;&#10;    private val client = HttpClient(CIO) {&#10;        install(WebSockets)&#10;    }&#10;&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private var currentHost: String = &quot;192.168.3.210&quot;&#10;    private var currentPort: Int = 81&#10;&#10;    fun connectWithPrefs(context: Context) {&#10;        val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, Context.MODE_PRIVATE)&#10;        val host = prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.210&quot;) ?: &quot;192.168.3.210&quot;&#10;        val port = prefs.getInt(&quot;ws_port&quot;, 81)&#10;        connect(host, port)&#10;    }&#10;&#10;    fun connect(host: String = currentHost, port: Int = currentPort) {&#10;        if (session?.isActive == true &amp;&amp; host == currentHost &amp;&amp; port == currentPort) return&#10;&#10;        currentHost = host&#10;        currentPort = port&#10;        _connectionStatus.value = ConnectionStatus.CONNECTING&#10;&#10;        scope.launch {&#10;            try {&#10;                client.webSocket(host = host, port = port, path = &quot;/ws&quot;) {&#10;                    session = this&#10;                    _connectionStatus.value = ConnectionStatus.CONNECTED&#10;                    println(&quot;WebSocket connection established.&quot;)&#10;                    // Nach Verbindungsaufbau Einstellungen anfordern&#10;                    send(Frame.Text(&quot;GET_SETTINGS&quot;))&#10;                    for (frame in incoming) {&#10;                        if (frame is Frame.Text) {&#10;                            messages.emit(frame.readText())&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot;WebSocket connection failed: \\${e.message}&quot;)&#10;                _connectionStatus.value = ConnectionStatus.ERROR&#10;            } finally {&#10;                println(&quot;WebSocket connection closed.&quot;)&#10;                session = null&#10;                if (_connectionStatus.value != ConnectionStatus.ERROR) {&#10;                    _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendMessage(message: String) {&#10;        scope.launch {&#10;            if (session?.isActive == true) {&#10;                println(&quot;Sending message: $message&quot;)&#10;                session?.send(Frame.Text(message))&#10;            } else {&#10;                println(&quot;Cannot send message, session is not active.&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        scope.launch {&#10;            session?.close()&#10;            session = null&#10;            _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;            println(&quot;WebSocket disconnected.&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>