<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/MainActivity.kt" />
              <option name="originalContent" value="package com.example.qlocktwo&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.qlocktwo.screens.MainScreen&#10;import com.example.qlocktwo.ui.theme.QlocktwoTheme&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;import com.example.qlocktwo.viewmodels.ColorViewModelFactory&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val webSocketManager = WebSocketManager()&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        webSocketManager.connectWithPrefs(this)&#10;        setContent {&#10;            val colorViewModel: ColorViewModel = androidx.lifecycle.viewmodel.compose.viewModel(&#10;                factory = ColorViewModelFactory(application)&#10;            )&#10;            QlocktwoTheme(darkTheme = true) {&#10;                MainScreen(&#10;                    webSocketManager = webSocketManager,&#10;                    colorViewModel = colorViewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.qlocktwo&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.example.qlocktwo.screens.MainScreen&#10;import com.example.qlocktwo.ui.theme.QlocktwoTheme&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;import com.example.qlocktwo.viewmodels.ColorViewModelFactory&#10;import kotlinx.coroutines.withTimeoutOrNull&#10;import kotlinx.coroutines.flow.first&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val webSocketManager = WebSocketManager()&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        webSocketManager.connectWithPrefs(this)&#10;        setContent {&#10;            val colorViewModel: ColorViewModel = androidx.lifecycle.viewmodel.compose.viewModel(&#10;                factory = ColorViewModelFactory(application)&#10;            )&#10;&#10;            var isLoading by remember { mutableStateOf(true) }&#10;&#10;            // Warte auf initiale Nachricht oder Timeout&#10;            LaunchedEffect(webSocketManager) {&#10;                // Warte maximal 5 Sekunden auf eine SETTINGS- oder TEMP-Nachricht&#10;                val result = withTimeoutOrNull(5000) {&#10;                    webSocketManager.messages.first { msg -&gt;&#10;                        msg.startsWith(&quot;SETTINGS:&quot;) || msg.startsWith(&quot;TEMP:&quot;)&#10;                    }&#10;                }&#10;&#10;                if (result != null) {&#10;                    println(&quot;Initial message received: $result&quot;)&#10;                } else {&#10;                    println(&quot;Loading timeout - showing UI anyway&quot;)&#10;                }&#10;                isLoading = false&#10;            }&#10;&#10;            // Kontinuierlich auf SETTINGS-Nachrichten hören und ColorViewModel aktualisieren&#10;            LaunchedEffect(webSocketManager) {&#10;                webSocketManager.currentSettings.collect { settingsMsg -&gt;&#10;                    settingsMsg?.let { msg -&gt;&#10;                        println(&quot;MainActivity processing SETTINGS: $msg&quot;)&#10;                        if (msg.startsWith(&quot;SETTINGS:&quot;)) {&#10;                            val parts = msg.removePrefix(&quot;SETTINGS:&quot;).split(&quot;,&quot;).map { it.trim() }&#10;                            if (parts.size &gt;= 5) {&#10;                                val r = parts[1].toIntOrNull() ?: 255&#10;                                val g = parts[2].toIntOrNull() ?: 0&#10;                                val b = parts[3].toIntOrNull() ?: 0&#10;                                val brightness = parts[4].toFloatOrNull() ?: 255f&#10;                                colorViewModel.updateColor(androidx.compose.ui.graphics.Color(r / 255f, g / 255f, b / 255f))&#10;                                colorViewModel.updateBrightness(brightness)&#10;                                println(&quot;Settings applied to ColorViewModel: r=$r g=$g b=$b brightness=$brightness&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            QlocktwoTheme(darkTheme = true) {&#10;                if (isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                            CircularProgressIndicator()&#10;                            Text(&quot;Verbinde mit Uhr...&quot;, modifier = Modifier.padding(top = 16.dp))&#10;                        }&#10;                    }&#10;                } else {&#10;                    MainScreen(&#10;                        webSocketManager = webSocketManager,&#10;                        colorViewModel = colorViewModel&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/WebSocketManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/WebSocketManager.kt" />
              <option name="originalContent" value="package com.example.qlocktwo&#10;&#10;import android.content.Context&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.engine.cio.CIO&#10;import io.ktor.client.plugins.websocket.WebSockets&#10;import io.ktor.client.plugins.websocket.webSocket&#10;import io.ktor.websocket.DefaultWebSocketSession&#10;import io.ktor.websocket.Frame&#10;import io.ktor.websocket.close&#10;import io.ktor.websocket.readText&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;&#10;enum class ConnectionStatus {&#10;    DISCONNECTED,&#10;    CONNECTING,&#10;    CONNECTED,&#10;    ERROR&#10;}&#10;&#10;class WebSocketManager {&#10;&#10;    val messages = MutableSharedFlow&lt;String&gt;(replay = 1)&#10;    private var session: DefaultWebSocketSession? = null&#10;&#10;    private val _connectionStatus = MutableStateFlow(ConnectionStatus.DISCONNECTED)&#10;    val connectionStatus: StateFlow&lt;ConnectionStatus&gt; = _connectionStatus.asStateFlow()&#10;&#10;    private val client = HttpClient(CIO) {&#10;        install(WebSockets)&#10;    }&#10;&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private var currentHost: String = &quot;192.168.3.210&quot;&#10;    private var currentPort: Int = 81&#10;&#10;    fun connectWithPrefs(context: Context) {&#10;        val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, Context.MODE_PRIVATE)&#10;        val host = prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.210&quot;) ?: &quot;192.168.3.210&quot;&#10;        val port = prefs.getInt(&quot;ws_port&quot;, 81)&#10;        connect(host, port)&#10;    }&#10;&#10;    fun connect(host: String = currentHost, port: Int = currentPort) {&#10;        if (session?.isActive == true &amp;&amp; host == currentHost &amp;&amp; port == currentPort) return&#10;&#10;        currentHost = host&#10;        currentPort = port&#10;        _connectionStatus.value = ConnectionStatus.CONNECTING&#10;&#10;        scope.launch {&#10;            try {&#10;                client.webSocket(host = host, port = port, path = &quot;/ws&quot;) {&#10;                    session = this&#10;                    _connectionStatus.value = ConnectionStatus.CONNECTED&#10;                    println(&quot;WebSocket connection established.&quot;)&#10;                    // Nach Verbindungsaufbau Einstellungen anfordern&#10;                    send(Frame.Text(&quot;GET_SETTINGS&quot;))&#10;                    for (frame in incoming) {&#10;                        if (frame is Frame.Text) {&#10;                            val msg = frame.readText()&#10;                            println(&quot;WebSocket received: $msg&quot;)&#10;                            messages.emit(msg)&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot;WebSocket connection failed: \\${e.message}&quot;)&#10;                _connectionStatus.value = ConnectionStatus.ERROR&#10;            } finally {&#10;                println(&quot;WebSocket connection closed.&quot;)&#10;                session = null&#10;                if (_connectionStatus.value != ConnectionStatus.ERROR) {&#10;                    _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendMessage(message: String) {&#10;        scope.launch {&#10;            if (session?.isActive == true) {&#10;                println(&quot;Sending message: $message&quot;)&#10;                session?.send(Frame.Text(message))&#10;            } else {&#10;                println(&quot;Cannot send message, session is not active.&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        scope.launch {&#10;            session?.close()&#10;            session = null&#10;            _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;            println(&quot;WebSocket disconnected.&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.qlocktwo&#10;&#10;import android.content.Context&#10;import io.ktor.client.HttpClient&#10;import io.ktor.client.engine.cio.CIO&#10;import io.ktor.client.plugins.websocket.WebSockets&#10;import io.ktor.client.plugins.websocket.webSocket&#10;import io.ktor.websocket.DefaultWebSocketSession&#10;import io.ktor.websocket.Frame&#10;import io.ktor.websocket.close&#10;import io.ktor.websocket.readText&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;&#10;enum class ConnectionStatus {&#10;    DISCONNECTED,&#10;    CONNECTING,&#10;    CONNECTED,&#10;    ERROR&#10;}&#10;&#10;class WebSocketManager {&#10;&#10;    val messages = MutableSharedFlow&lt;String&gt;(replay = 0)&#10;    private var session: DefaultWebSocketSession? = null&#10;&#10;    private val _connectionStatus = MutableStateFlow(ConnectionStatus.DISCONNECTED)&#10;    val connectionStatus: StateFlow&lt;ConnectionStatus&gt; = _connectionStatus.asStateFlow()&#10;    &#10;    // StateFlow für aktuelle Settings, damit mehrere Komponenten darauf zugreifen können&#10;    private val _currentSettings = MutableStateFlow&lt;String?&gt;(null)&#10;    val currentSettings: StateFlow&lt;String?&gt; = _currentSettings.asStateFlow()&#10;&#10;    private val client = HttpClient(CIO) {&#10;        install(WebSockets)&#10;    }&#10;&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private var currentHost: String = &quot;192.168.3.210&quot;&#10;    private var currentPort: Int = 81&#10;&#10;    fun connectWithPrefs(context: Context) {&#10;        val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, Context.MODE_PRIVATE)&#10;        val host = prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.210&quot;) ?: &quot;192.168.3.210&quot;&#10;        val port = prefs.getInt(&quot;ws_port&quot;, 81)&#10;        connect(host, port)&#10;    }&#10;&#10;    fun connect(host: String = currentHost, port: Int = currentPort) {&#10;        if (session?.isActive == true &amp;&amp; host == currentHost &amp;&amp; port == currentPort) return&#10;&#10;        currentHost = host&#10;        currentPort = port&#10;        _connectionStatus.value = ConnectionStatus.CONNECTING&#10;&#10;        scope.launch {&#10;            try {&#10;                client.webSocket(host = host, port = port, path = &quot;/ws&quot;) {&#10;                    session = this&#10;                    _connectionStatus.value = ConnectionStatus.CONNECTED&#10;                    println(&quot;WebSocket connection established.&quot;)&#10;                    // Nach Verbindungsaufbau Einstellungen anfordern&#10;                    send(Frame.Text(&quot;GET_SETTINGS&quot;))&#10;                    for (frame in incoming) {&#10;                        if (frame is Frame.Text) {&#10;                            val msg = frame.readText()&#10;                            println(&quot;WebSocket received: $msg&quot;)&#10;                            &#10;                            // Settings separat im StateFlow speichern&#10;                            if (msg.startsWith(&quot;SETTINGS:&quot;)) {&#10;                                _currentSettings.value = msg&#10;                            }&#10;                            &#10;                            messages.emit(msg)&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot;WebSocket connection failed: \\${e.message}&quot;)&#10;                _connectionStatus.value = ConnectionStatus.ERROR&#10;            } finally {&#10;                println(&quot;WebSocket connection closed.&quot;)&#10;                session = null&#10;                if (_connectionStatus.value != ConnectionStatus.ERROR) {&#10;                    _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendMessage(message: String) {&#10;        scope.launch {&#10;            if (session?.isActive == true) {&#10;                println(&quot;Sending message: $message&quot;)&#10;                session?.send(Frame.Text(message))&#10;            } else {&#10;                println(&quot;Cannot send message, session is not active.&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        scope.launch {&#10;            session?.close()&#10;            session = null&#10;            _connectionStatus.value = ConnectionStatus.DISCONNECTED&#10;            println(&quot;WebSocket disconnected.&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/screens/SettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/qlocktwo/screens/SettingsScreen.kt" />
              <option name="originalContent" value="package com.example.qlocktwo.screens&#10;&#10;import android.app.TimePickerDialog&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import com.example.qlocktwo.R&#10;import com.example.qlocktwo.WebSocketManager&#10;import kotlinx.coroutines.flow.collectLatest&#10;import java.util.Calendar&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SettingsScreen(&#10;    webSocketManager: WebSocketManager,&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, android.content.Context.MODE_PRIVATE)&#10;&#10;    var isScheduleEnabled by remember {&#10;        mutableStateOf(prefs.getBoolean(&quot;schedule_enabled&quot;, false))&#10;    }&#10;    var startHour by remember { mutableStateOf(prefs.getInt(&quot;start_hour&quot;, 7)) }&#10;    var startMinute by remember { mutableStateOf(prefs.getInt(&quot;start_minute&quot;, 0)) }&#10;    var endHour by remember { mutableStateOf(prefs.getInt(&quot;end_hour&quot;, 22)) }&#10;    var endMinute by remember { mutableStateOf(prefs.getInt(&quot;end_minute&quot;, 0)) }&#10;&#10;    var ipAddress by remember { mutableStateOf(prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.210&quot;) ?: &quot;192.168.3.210&quot;) }&#10;    var port by remember { mutableStateOf(prefs.getInt(&quot;ws_port&quot;, 81).toString()) }&#10;    var ipError by remember { mutableStateOf(false) }&#10;    var portError by remember { mutableStateOf(false) }&#10;&#10;    var currentMode by remember { mutableStateOf(&quot;CLOCK&quot;) }&#10;    val colorViewModel: ColorViewModel = viewModel()&#10;    val selectedColor by colorViewModel::selectedColor&#10;    val brightness by colorViewModel::brightness&#10;&#10;    var isLoading by remember { mutableStateOf(true) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Einstellungen&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            painter = painterResource(id = android.R.drawable.ic_menu_revert),&#10;                            contentDescription = &quot;Zurück&quot;&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(24.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Allgemeine Einstellungen&quot;,&#10;                style = MaterialTheme.typography.titleLarge,&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // IP/Port Card&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&quot;Verbindungsdaten&quot;, style = MaterialTheme.typography.titleMedium)&#10;                    androidx.compose.material3.OutlinedTextField(&#10;                        value = ipAddress,&#10;                        onValueChange = {&#10;                            ipAddress = it&#10;                            ipError = !Regex(&quot;^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;).matches(it)&#10;                        },&#10;                        label = { Text(&quot;IP-Adresse&quot;) },&#10;                        isError = ipError,&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                    if (ipError) Text(&quot;Ungültige IP-Adresse&quot;, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)&#10;                    androidx.compose.material3.OutlinedTextField(&#10;                        value = port,&#10;                        onValueChange = {&#10;                            port = it.filter { c -&gt; c.isDigit() }&#10;                            portError = port.isEmpty() || port.toIntOrNull() == null || port.toInt() !in 1..65535&#10;                        },&#10;                        label = { Text(&quot;Port&quot;) },&#10;                        isError = portError,&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                    if (portError) Text(&quot;Ungültiger Port (1-65535)&quot;, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)&#10;                    Button(&#10;                        onClick = {&#10;                            if (!ipError &amp;&amp; !portError) {&#10;                                prefs.edit().putString(&quot;ws_ip&quot;, ipAddress).putInt(&quot;ws_port&quot;, port.toInt()).apply()&#10;                                webSocketManager.disconnect()&#10;                                webSocketManager.connect(ipAddress, port.toInt())&#10;                            }&#10;                        },&#10;                        enabled = !ipError &amp;&amp; !portError,&#10;                        modifier = Modifier.align(Alignment.End)&#10;                    ) {&#10;                        Text(&quot;Übernehmen &amp; neu verbinden&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(18.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&quot;Zeitplan aktivieren&quot;, style = MaterialTheme.typography.bodyLarge)&#10;                        Switch(&#10;                            checked = isScheduleEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                isScheduleEnabled = enabled&#10;                                prefs.edit().putBoolean(&quot;schedule_enabled&quot;, enabled).apply()&#10;                                val message = if (enabled) {&#10;                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                } else {&#10;                                    &quot;SCHEDULE:OFF&quot;&#10;                                }&#10;                                webSocketManager.sendMessage(message)&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    if (isScheduleEnabled) {&#10;                        Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&quot;Startzeit&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                Button(&#10;                                    onClick = {&#10;                                        TimePickerDialog(&#10;                                            context,&#10;                                            { _, hour, minute -&gt;&#10;                                                startHour = hour&#10;                                                startMinute = minute&#10;                                                prefs.edit()&#10;                                                    .putInt(&quot;start_hour&quot;, hour)&#10;                                                    .putInt(&quot;start_minute&quot;, minute)&#10;                                                    .apply()&#10;                                                webSocketManager.sendMessage(&#10;                                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                                )&#10;                                            },&#10;                                            startHour,&#10;                                            startMinute,&#10;                                            true&#10;                                        ).show()&#10;                                    },&#10;                                    shape = MaterialTheme.shapes.medium&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = android.R.drawable.ic_menu_recent_history),&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.padding(end = 4.dp)&#10;                                    )&#10;                                    Text(String.format(&quot;%02d:%02d&quot;, startHour, startMinute))&#10;                                }&#10;                            }&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&quot;Endzeit&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                Button(&#10;                                    onClick = {&#10;                                        TimePickerDialog(&#10;                                            context,&#10;                                            { _, hour, minute -&gt;&#10;                                                endHour = hour&#10;                                                endMinute = minute&#10;                                                prefs.edit()&#10;                                                    .putInt(&quot;end_hour&quot;, hour)&#10;                                                    .putInt(&quot;end_minute&quot;, minute)&#10;                                                    .apply()&#10;                                                webSocketManager.sendMessage(&#10;                                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                                )&#10;                                            },&#10;                                            endHour,&#10;                                            endMinute,&#10;                                            true&#10;                                        ).show()&#10;                                    },&#10;                                    shape = MaterialTheme.shapes.medium&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = android.R.drawable.ic_menu_recent_history),&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.padding(end = 4.dp)&#10;                                    )&#10;                                    Text(String.format(&quot;%02d:%02d&quot;, endHour, endMinute))&#10;                                }&#10;                            }&#10;                            Text(&#10;                                text = &quot;Die Uhr ist aktiv von ${String.format(&quot;%02d:%02d&quot;, startHour, startMinute)} bis ${String.format(&quot;%02d:%02d&quot;, endHour, endMinute)}.&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                                modifier = Modifier.padding(top = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Modus-Auswahl&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&quot;Modus wählen&quot;, style = MaterialTheme.typography.titleMedium)&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        val modes = listOf(&quot;CLOCK&quot;, &quot;DIGITAL&quot;, &quot;MATRIX&quot;, &quot;TEMPERATURE&quot;)&#10;                        modes.forEach { mode -&gt;&#10;                            Button(&#10;                                onClick = {&#10;                                    currentMode = mode&#10;                                    webSocketManager.sendMessage(&quot;SET_MODE:$mode&quot;)&#10;                                },&#10;                                colors = if (currentMode == mode)&#10;                                    ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.primary)&#10;                                else&#10;                                    ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;                            ) {&#10;                                Text(mode)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // Farb- und Helligkeitssteuerung&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&quot;Farbe wählen&quot;, style = MaterialTheme.typography.titleMedium)&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        val colors = listOf(&#10;                            Color.Red, Color.Green, Color.Blue, Color.Yellow, Color.Cyan, Color.Magenta, Color.White&#10;                        )&#10;                        colors.forEach { color -&gt;&#10;                            Button(&#10;                                onClick = { colorViewModel.updateColor(color) },&#10;                                colors = ButtonDefaults.buttonColors(containerColor = color)&#10;                            ) {&#10;                                if (selectedColor == color) Text(&quot;✓&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                    Text(&quot;Helligkeit: ${brightness.toInt()}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                    androidx.compose.material3.Slider(&#10;                        value = brightness,&#10;                        onValueChange = { colorViewModel.updateBrightness(it) },&#10;                        valueRange = 0f..255f,&#10;                        steps = 10,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;&#10;            Button(&#10;                onClick = {&#10;                    val message = if (isScheduleEnabled) {&#10;                        &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                    } else {&#10;                        &quot;SCHEDULE:OFF&quot;&#10;                    }&#10;                    webSocketManager.sendMessage(message)&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = MaterialTheme.shapes.medium&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(id = android.R.drawable.ic_menu_send),&#10;                    contentDescription = null,&#10;                    modifier = Modifier.padding(end = 6.dp)&#10;                )&#10;                Text(&quot;Einstellungen an Uhr senden&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(webSocketManager) {&#10;        webSocketManager.messages.collectLatest { msg -&gt;&#10;            println(&quot;SettingsScreen received: $msg&quot;) // Debug-Log für jede empfangene Nachricht&#10;            if (msg.startsWith(&quot;SETTINGS:&quot;)) {&#10;                val parts = msg.removePrefix(&quot;SETTINGS:&quot;).split(&quot;,&quot;).map { it.trim() }&#10;                println(&quot;SettingsScreen parts: $parts size=${parts.size}&quot;)&#10;                if (parts.size &gt;= 5) {&#10;                    val mode = parts[0]&#10;                    val r = parts[1].toIntOrNull() ?: 255&#10;                    val g = parts[2].toIntOrNull() ?: 0&#10;                    val b = parts[3].toIntOrNull() ?: 0&#10;                    val brightness = parts[4].toFloatOrNull() ?: 255f&#10;                    println(&quot;SettingsScreen parsed: mode=$mode r=$r g=$g b=$b brightness=$brightness&quot;)&#10;                    currentMode = mode&#10;                    colorViewModel.updateColor(Color(r, g, b))&#10;                    colorViewModel.updateBrightness(brightness)&#10;                    isLoading = false&#10;                } else {&#10;                    println(&quot;SettingsScreen: SETTINGS message has not enough parts: $parts&quot;)&#10;                }&#10;            }&#10;            if (msg.startsWith(&quot;TEMP:&quot;)) {&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    if (isLoading) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            CircularProgressIndicator()&#10;            Text(&quot;Lade Einstellungen...&quot;, modifier = Modifier.padding(top = 64.dp))&#10;        }&#10;        return&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.qlocktwo.screens&#10;&#10;import android.app.TimePickerDialog&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Switch&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import com.example.qlocktwo.R&#10;import com.example.qlocktwo.WebSocketManager&#10;import kotlinx.coroutines.flow.collectLatest&#10;import java.util.Calendar&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.qlocktwo.viewmodels.ColorViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SettingsScreen(&#10;    webSocketManager: WebSocketManager,&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;QlockSettings&quot;, android.content.Context.MODE_PRIVATE)&#10;&#10;    var isScheduleEnabled by remember {&#10;        mutableStateOf(prefs.getBoolean(&quot;schedule_enabled&quot;, false))&#10;    }&#10;    var startHour by remember { mutableStateOf(prefs.getInt(&quot;start_hour&quot;, 7)) }&#10;    var startMinute by remember { mutableStateOf(prefs.getInt(&quot;start_minute&quot;, 0)) }&#10;    var endHour by remember { mutableStateOf(prefs.getInt(&quot;end_hour&quot;, 22)) }&#10;    var endMinute by remember { mutableStateOf(prefs.getInt(&quot;end_minute&quot;, 0)) }&#10;&#10;    var ipAddress by remember { mutableStateOf(prefs.getString(&quot;ws_ip&quot;, &quot;192.168.3.210&quot;) ?: &quot;192.168.3.210&quot;) }&#10;    var port by remember { mutableStateOf(prefs.getInt(&quot;ws_port&quot;, 81).toString()) }&#10;    var ipError by remember { mutableStateOf(false) }&#10;    var portError by remember { mutableStateOf(false) }&#10;&#10;    var currentMode by remember { mutableStateOf(&quot;CLOCK&quot;) }&#10;    val colorViewModel: ColorViewModel = viewModel()&#10;&#10;    // Beobachte currentSettings StateFlow statt messages SharedFlow&#10;    val currentSettingsMsg by webSocketManager.currentSettings.collectAsState()&#10;    &#10;    LaunchedEffect(currentSettingsMsg) {&#10;        currentSettingsMsg?.let { msg -&gt;&#10;            println(&quot;SettingsScreen received: $msg&quot;)&#10;            if (msg.startsWith(&quot;SETTINGS:&quot;)) {&#10;                val parts = msg.removePrefix(&quot;SETTINGS:&quot;).split(&quot;,&quot;).map { it.trim() }&#10;                println(&quot;SettingsScreen parts: $parts size=${parts.size}&quot;)&#10;                if (parts.size &gt;= 5) {&#10;                    val mode = parts[0]&#10;                    val r = parts[1].toIntOrNull() ?: 255&#10;                    val g = parts[2].toIntOrNull() ?: 0&#10;                    val b = parts[3].toIntOrNull() ?: 0&#10;                    val brightnessValue = parts[4].toFloatOrNull() ?: 255f&#10;                    println(&quot;SettingsScreen parsed: mode=$mode r=$r g=$g b=$b brightness=$brightnessValue&quot;)&#10;                    currentMode = mode&#10;                    colorViewModel.updateColor(Color(r / 255f, g / 255f, b / 255f))&#10;                    colorViewModel.updateBrightness(brightnessValue)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Einstellungen&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            painter = painterResource(id = android.R.drawable.ic_menu_revert),&#10;                            contentDescription = &quot;Zurück&quot;&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(24.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Allgemeine Einstellungen&quot;,&#10;                style = MaterialTheme.typography.titleLarge,&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // IP/Port Card&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&quot;Verbindungsdaten&quot;, style = MaterialTheme.typography.titleMedium)&#10;                    androidx.compose.material3.OutlinedTextField(&#10;                        value = ipAddress,&#10;                        onValueChange = {&#10;                            ipAddress = it&#10;                            ipError = !Regex(&quot;^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;).matches(it)&#10;                        },&#10;                        label = { Text(&quot;IP-Adresse&quot;) },&#10;                        isError = ipError,&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                    if (ipError) Text(&quot;Ungültige IP-Adresse&quot;, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)&#10;                    androidx.compose.material3.OutlinedTextField(&#10;                        value = port,&#10;                        onValueChange = {&#10;                            port = it.filter { c -&gt; c.isDigit() }&#10;                            portError = port.isEmpty() || port.toIntOrNull() == null || port.toInt() !in 1..65535&#10;                        },&#10;                        label = { Text(&quot;Port&quot;) },&#10;                        isError = portError,&#10;                        singleLine = true,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                    if (portError) Text(&quot;Ungültiger Port (1-65535)&quot;, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)&#10;                    Button(&#10;                        onClick = {&#10;                            if (!ipError &amp;&amp; !portError) {&#10;                                prefs.edit().putString(&quot;ws_ip&quot;, ipAddress).putInt(&quot;ws_port&quot;, port.toInt()).apply()&#10;                                webSocketManager.disconnect()&#10;                                webSocketManager.connect(ipAddress, port.toInt())&#10;                            }&#10;                        },&#10;                        enabled = !ipError &amp;&amp; !portError,&#10;                        modifier = Modifier.align(Alignment.End)&#10;                    ) {&#10;                        Text(&quot;Übernehmen &amp; neu verbinden&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(18.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&quot;Zeitplan aktivieren&quot;, style = MaterialTheme.typography.bodyLarge)&#10;                        Switch(&#10;                            checked = isScheduleEnabled,&#10;                            onCheckedChange = { enabled -&gt;&#10;                                isScheduleEnabled = enabled&#10;                                prefs.edit().putBoolean(&quot;schedule_enabled&quot;, enabled).apply()&#10;                                val message = if (enabled) {&#10;                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                } else {&#10;                                    &quot;SCHEDULE:OFF&quot;&#10;                                }&#10;                                webSocketManager.sendMessage(message)&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    if (isScheduleEnabled) {&#10;                        Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&quot;Startzeit&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                Button(&#10;                                    onClick = {&#10;                                        TimePickerDialog(&#10;                                            context,&#10;                                            { _, hour, minute -&gt;&#10;                                                startHour = hour&#10;                                                startMinute = minute&#10;                                                prefs.edit()&#10;                                                    .putInt(&quot;start_hour&quot;, hour)&#10;                                                    .putInt(&quot;start_minute&quot;, minute)&#10;                                                    .apply()&#10;                                                webSocketManager.sendMessage(&#10;                                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                                )&#10;                                            },&#10;                                            startHour,&#10;                                            startMinute,&#10;                                            true&#10;                                        ).show()&#10;                                    },&#10;                                    shape = MaterialTheme.shapes.medium&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = android.R.drawable.ic_menu_recent_history),&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.padding(end = 4.dp)&#10;                                    )&#10;                                    Text(String.format(&quot;%02d:%02d&quot;, startHour, startMinute))&#10;                                }&#10;                            }&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&quot;Endzeit&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                Button(&#10;                                    onClick = {&#10;                                        TimePickerDialog(&#10;                                            context,&#10;                                            { _, hour, minute -&gt;&#10;                                                endHour = hour&#10;                                                endMinute = minute&#10;                                                prefs.edit()&#10;                                                    .putInt(&quot;end_hour&quot;, hour)&#10;                                                    .putInt(&quot;end_minute&quot;, minute)&#10;                                                    .apply()&#10;                                                webSocketManager.sendMessage(&#10;                                                    &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                                                )&#10;                                            },&#10;                                            endHour,&#10;                                            endMinute,&#10;                                            true&#10;                                        ).show()&#10;                                    },&#10;                                    shape = MaterialTheme.shapes.medium&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = android.R.drawable.ic_menu_recent_history),&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier.padding(end = 4.dp)&#10;                                    )&#10;                                    Text(String.format(&quot;%02d:%02d&quot;, endHour, endMinute))&#10;                                }&#10;                            }&#10;                            Text(&#10;                                text = &quot;Die Uhr ist aktiv von ${String.format(&quot;%02d:%02d&quot;, startHour, startMinute)} bis ${String.format(&quot;%02d:%02d&quot;, endHour, endMinute)}.&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                                modifier = Modifier.padding(top = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Modus-Auswahl&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&quot;Modus wählen&quot;, style = MaterialTheme.typography.titleMedium)&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        val modes = listOf(&quot;CLOCK&quot;, &quot;DIGITAL&quot;, &quot;MATRIX&quot;, &quot;TEMPERATURE&quot;)&#10;                        modes.forEach { mode -&gt;&#10;                            Button(&#10;                                onClick = {&#10;                                    currentMode = mode&#10;                                    webSocketManager.sendMessage(&quot;SET_MODE:$mode&quot;)&#10;                                },&#10;                                colors = if (currentMode == mode)&#10;                                    ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.primary)&#10;                                else&#10;                                    ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;                            ) {&#10;                                Text(mode)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // Farb- und Helligkeitssteuerung&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Text(&quot;Farbe wählen&quot;, style = MaterialTheme.typography.titleMedium)&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        val colors = listOf(&#10;                            Color.Red, Color.Green, Color.Blue, Color.Yellow, Color.Cyan, Color.Magenta, Color.White&#10;                        )&#10;                        colors.forEach { color -&gt;&#10;                            Button(&#10;                                onClick = { colorViewModel.updateColor(color) },&#10;                                colors = ButtonDefaults.buttonColors(containerColor = color)&#10;                            ) {&#10;                                if (colorViewModel.selectedColor == color) Text(&quot;✓&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                    Text(&quot;Helligkeit: ${colorViewModel.brightness.toInt()}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                    androidx.compose.material3.Slider(&#10;                        value = colorViewModel.brightness,&#10;                        onValueChange = { colorViewModel.updateBrightness(it) },&#10;                        valueRange = 0f..255f,&#10;                        steps = 10,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;&#10;            Button(&#10;                onClick = {&#10;                    val message = if (isScheduleEnabled) {&#10;                        &quot;SCHEDULE:ON,$startHour:$startMinute,$endHour:$endMinute&quot;&#10;                    } else {&#10;                        &quot;SCHEDULE:OFF&quot;&#10;                    }&#10;                    webSocketManager.sendMessage(message)&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = MaterialTheme.shapes.medium&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(id = android.R.drawable.ic_menu_send),&#10;                    contentDescription = null,&#10;                    modifier = Modifier.padding(end = 6.dp)&#10;                )&#10;                Text(&quot;Einstellungen an Uhr senden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>